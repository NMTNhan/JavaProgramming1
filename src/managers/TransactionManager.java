package managers;

import models.Transaction;
import models.Service;
import utils.FileUtils;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class TransactionManager {

    // File paths for transactions, services, and parts data
    private static final String TRANSACTION_FILE_PATH = "src/data/transactions";
    private static final String SERVICE_FILE_PATH = "src/data/services";
    private static final String PART_FILE_PATH = "src/data/parts";

    // Lists to hold transactions, services, and parts
    private List<Transaction> transactions = new ArrayList<>();
    private List<String[]> services;
    private List<String[]> parts;
    // This variable keeps track of the last used transaction ID
    private int lastTransactionNumber = 0;

    // Constructor: Load data from files
    public TransactionManager() {
        loadServicesFromFile();
        loadPartsFromFile();
        loadTransactionsFromFile();
    }

    // Load services from file
    private void loadServicesFromFile() {
        List<String> serviceLines = FileUtils.readFile(SERVICE_FILE_PATH);
        services = serviceLines.stream().map(line -> line.split("\\|")).collect(Collectors.toList());
    }

    // Load parts from file
    private void loadPartsFromFile() {
        List<String> partLines = FileUtils.readFile(PART_FILE_PATH);
        parts = partLines.stream().map(line -> line.split(",")).collect(Collectors.toList());
    }

    // Load transactions from file
    private void loadTransactionsFromFile() {
        List<String> transactionLines = FileUtils.readFile(TRANSACTION_FILE_PATH);
        for (String line : transactionLines) {
            transactions.add(deserializeTransaction(line));  // Assuming deserializeTransaction() exists
        }
    }

    // Convert a line of string data from file to Transaction object
    private Transaction deserializeTransaction(String line) {
        String[] data = line.split(",");
        String transactionID = data[0];
        LocalDate transactionDate = LocalDate.parse(data[1]);
        String clientID = data[2];
        String salespersonID = data[3];
        String mechanicID = data[4];
        List<String> purchasedItems = List.of(data[5].split(";"));
        double discount = Double.parseDouble(data[6]);
        double totalAmount = Double.parseDouble(data[7]);
        String additionalNotes = data[8];

        return new Transaction(transactionID, transactionDate, clientID, salespersonID, mechanicID, purchasedItems, discount, totalAmount, additionalNotes);
    }

    // Generate the next transaction ID
    public String generateTransactionID() {
        lastTransactionNumber++;
        return String.format("T%03d", lastTransactionNumber);  // Format as T001, T002, etc.
    }

    // Add a new transaction
    public void addTransaction(Transaction transaction) {
        transactions.add(transaction);
        System.out.println("Transaction added successfully.");
    }

    // Save transactions to file (to update after CRUD operations)
    private void saveTransactionsToFile() {
        List<String> serializedTransactions = transactions.stream()
                .map(this::serializeTransaction)
                .collect(Collectors.toList());
        FileUtils.writeFile(TRANSACTION_FILE_PATH, serializedTransactions);
    }

    // Convert a Transaction object to a string for saving to file
    private String serializeTransaction(Transaction transaction) {
        String purchasedItems = String.join(";", transaction.getPurchasedItems());
        return transaction.getTransactionID() + "," + transaction.getTransactionDate() + "," + transaction.getClientID() + ","
                + transaction.getSalespersonID() + "," + transaction.getMechanicID() + "," + purchasedItems + "," + transaction.getDiscount() + ","
                + transaction.getTotalAmount() + "," + transaction.getAdditionalNotes();
    }

    // Calculate total revenue in a time period
    public double calculateRevenue(LocalDate startDate, LocalDate endDate) {
        return transactions.stream()
                .filter(transaction -> (transaction.getTransactionDate().isEqual(startDate) || transaction.getTransactionDate().isAfter(startDate))
                        && (transaction.getTransactionDate().isEqual(endDate) || transaction.getTransactionDate().isBefore(endDate)))
                .mapToDouble(Transaction::getTotalAmount)
                .sum();
    }

    // Calculate revenue generated by a specific mechanic
    public double calculateMechanicRevenue(String mechanicID, LocalDate startDate, LocalDate endDate) {
        return transactions.stream()
                .filter(transaction -> mechanicID.equals(transaction.getMechanicID()))
                .filter(transaction -> (transaction.getTransactionDate().isEqual(startDate) || transaction.getTransactionDate().isAfter(startDate))
                        && (transaction.getTransactionDate().isEqual(endDate) || transaction.getTransactionDate().isBefore(endDate)))
                .mapToDouble(Transaction::getTotalAmount)
                .sum();
    }

    // Calculate revenue generated by a specific salesperson
    public double calculateSalespersonRevenue(String salespersonID, LocalDate startDate, LocalDate endDate) {
        return transactions.stream()
                .filter(transaction -> salespersonID.equals(transaction.getSalespersonID()))
                .filter(transaction -> (transaction.getTransactionDate().isEqual(startDate) || transaction.getTransactionDate().isAfter(startDate))
                        && (transaction.getTransactionDate().isEqual(endDate) || transaction.getTransactionDate().isBefore(endDate)))
                .mapToDouble(Transaction::getTotalAmount)
                .sum();
    }

    // Method to list all transactions
    public List<Transaction> listTransactions(LocalDate startDate, LocalDate endDate) {
        return transactions.stream()
                .filter(t -> !t.getTransactionDate().isBefore(startDate) && !t.getTransactionDate().isAfter(endDate))
                .collect(Collectors.toList());
    }

    // Method to calculate cars sold in a month
    public long calculateCarsSoldInMonth(int month, int year) {
        return transactions.stream()
                .filter(transaction -> transaction.getTransactionDate().getMonthValue() == month && transaction.getTransactionDate().getYear() == year)
                .count();  // This returns a long
    }


    // List cars sold in a time period
    public void listCarsSold(LocalDate startDate, LocalDate endDate) {
        List<Transaction> carsSold = transactions.stream()
                .filter(transaction -> transaction.getSalespersonID() != null) // Transactions handled by salespersons are car sales
                .filter(transaction -> !transaction.getPurchasedItems().isEmpty()) // Ensure there are purchased items
                .filter(transaction -> !transaction.getSalespersonID().isEmpty())
                .filter(transaction -> (transaction.getTransactionDate().isEqual(startDate) || transaction.getTransactionDate().isAfter(startDate))
                        && (transaction.getTransactionDate().isEqual(endDate) || transaction.getTransactionDate().isBefore(endDate)))
                .collect(Collectors.toList());

        if (carsSold.isEmpty()) {
            System.out.println("No cars sold in the given period.");
        } else {
            carsSold.forEach(System.out::println);
        }
    }

    // List services performed in a time period
    public void listServicesPerformed(LocalDate startDate, LocalDate endDate) {
        List<Transaction> servicesPerformed = transactions.stream()
                .filter(transaction -> transaction.getMechanicID() != null && !transaction.getMechanicID().isEmpty()) // Transactions handled by mechanics are services
                .filter(transaction -> (transaction.getTransactionDate().isEqual(startDate) || transaction.getTransactionDate().isAfter(startDate))
                        && (transaction.getTransactionDate().isEqual(endDate) || transaction.getTransactionDate().isBefore(endDate)))
                .collect(Collectors.toList());

        if (servicesPerformed.isEmpty()) {
            System.out.println("No services performed in the given period.");
        } else {
            servicesPerformed.forEach(System.out::println);
        }
    }

    // Method to list auto parts sold
    public List<String> listAutoPartsSold(LocalDate startDate, LocalDate endDate) {
        return transactions.stream()
                .filter(t -> !t.getTransactionDate().isBefore(startDate) && !t.getTransactionDate().isAfter(endDate))
                .flatMap(t -> t.getPurchasedItems().stream())
                .filter(item -> item.startsWith("p"))  // Assuming part IDs start with 'P'
                .collect(Collectors.toList());
    }

    // Print all transactions
    public void getAllTransactions() {
        if (transactions.isEmpty()) {
            System.out.println("No transactions available.");
        } else {
            transactions.forEach(System.out::println);
        }
    }
    // Find a transaction by its ID and return the transaction object (not void)
    public Transaction findTransactionById(String transactionId) {
        for (Transaction transaction : transactions) {
            if (transaction.getTransactionID().equals(transactionId)) {
                return transaction;  // Return the transaction if found
            }
        }
        return null;  // Return null if no transaction is found
    }

}
